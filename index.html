<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>a2rp - react.js notes</title>
        <style type="text/css">
            * {
                padding: 0;
                margin: 0;
                box-sizing: border-box;
                font-family: Verdana, sans-serif;
                font-size: 13px;
                line-height: 21px;
            }

            html {
                scroll-behavior: smooth !important;
            }

            .container {
                padding: 15px;
            }
            h3 {
                margin-top: 15px;
                margin-bottom: 15px;
            }
            pre {
                white-space: pre-wrap; /* Since CSS 2.1 */
                white-space: -moz-pre-wrap; /* Mozilla, since 1999 */
                white-space: -pre-wrap; /* Opera 4-6 */
                white-space: -o-pre-wrap; /* Opera 7 */
                word-wrap: break-word; /* Internet Explorer 5.5+ */
                background-color: #eee;
                padding: 15px;
                margin-top: 15px;
                margin-bottom: 15px;
            }
            ul {
                padding-left: 30px;
            }
            table thead tr th {
                background-color: #222;
                color: #fff;
                font-weight: bolder;
            }
            table thead tr th,
            table tbody tr td {
                border: 1px solid #000;
                padding: 10px;
            }
            .a2rpRight {
                background-color: #000;
                color: #aaa;
                padding: 5px;
                padding-right: 15px;
                text-align: right;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h3>Date: July 13, 2023</h3>

            <h3>ReactJS Notes</h3>
            React (also known as React.js or ReactJS) is a free and open-source
            front-end JavaScript library for building user interfaces based on
            components. It is maintained by Meta (formerly Facebook) and a
            community of individual developers and companies.
            <br />
            React can be used to develop single-page, mobile, or server-rendered
            applications with frameworks like Next.js. Because React is only
            concerned with the user interface and rendering components to the
            DOM, React applications often rely on libraries for routing and
            other client-side functionality.

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>create react app</h3>
            <pre>npx create-react-app app-name</pre>

            <h3>execute react application</h3>
            from inside "app-name folder"
            <pre>npm run start</pre>

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>Introduction</h3>
            <b>React creates a VIRTUAL DOM in memory.</b> Instead of
            manipulating the browser's DOM directly, React creates a virtual DOM
            in memory, where it does all the necessary manipulating, before
            making the changes in the browser DOM.
            <br />
            <b>React only changes what needs to be changed!</b> React finds out
            what changes have been made, and changes only what needs to be
            changed.

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>History</h3>
            <ul>
                <li>
                    2010: THE FIRST SIGNS OF REACT - Facebook introduced XHP
                    into its PHP stack and open-sourced it.
                </li>
                <li>
                    2011: AN EARLY PROTOTYPE - Jordan Walke created FaxJS, the
                    early prototype of React - shipped a search element on
                    Facebook.
                </li>
                <li>
                    2013: THE BIG LAUNCH OF REACT - JS Confus, Jordan Walke
                    introduced React. React gets open-sourced.
                </li>
                <li>
                    Early 2014: ReactJSWorldTour - ReactJSWorldTour conferences
                    started to build community and to "turn haters into
                    advocates".
                </li>
                <li>
                    Jan 2014: REACT DEVELOPER TOOLS - React Developer Tools
                    becomes an extension of the Chrome Developer Tools.
                </li>
                <li>
                    March 2015: REACT NATIVE - React Native, which enables
                    native Android, iOS, and UWP development with React, was
                    open-sourced.
                </li>
                <li>
                    June 2015: REDUX RELEASED - Redux was released by Dan
                    Abramov and Andrew Clark.
                </li>
                <li>
                    April 2017: REACT FIBER - Facebook announced React Fiber, a
                    new core algorithm of React Framework linrary for building
                    user interfaces.
                </li>
                <li>
                    September 26, 2017: React 16.0 was released to the public.
                </li>
                <li>
                    August 10, 2020: the React team announced the first release
                    candidate for React v17.0, notable as the first major
                    release without major changes to the React developer-facing
                    API.
                </li>
                <li>
                    March 29, 2022: React 18 was released which introduced a new
                    concurrent renderer, automatic batching and support for
                    server side rendering with Suspense.
                </li>
                <li>14 June 2022: Current version of React.JS is 18.2.0.</li>
            </ul>

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>React with CDN</h3>
            <pre>
&lt;!DOCTYPE html>
&lt;html>
	&lt;head>
		&lt;script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin>&lt;/script>
	    &lt;script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin>&lt;/script>
	    &lt;script src="https://unpkg.com/@babel/standalone/babel.min.js">&lt;/script>
	&lt;/head>
  	&lt;body>
  		&lt;div id="mydiv">&lt;/div>

	    &lt;script type="text/babel">
	    	function Hello() {
	    		return &lt;h1>Hello World!&lt;/h1>;
	    	}

	    	const container = document.getElementById('mydiv');
	      	const root = ReactDOM.createRoot(container);
	      	root.render(&lt;Hello />)
	    &lt;/script>

	&lt;/body>
	&lt;/html>
		</pre
            >

            This way of using React can be OK for testing purposes, but for
            production we will need to set up a React environment.
            <br />
            to create a react app:
            <pre>npx create-react-app app-name</pre>

            to run a react app: from inside app-name folder
            <pre>npm run start</pre>

            In browser visit "http://localhost:3000" to use the application. We
            may edit the "app-name/src/App.js" file to see changes in the
            application. The changes are visible immediately after we save the
            file, we do not have to reload the browser!

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>ES6 [ECMAScript 6]</h3>
            ECMAScript was created to standardize JavaScript, and ES6 is the 6th
            version of ECMAScript, it was published in 2015, and is also known
            as ECMAScript 2015. React uses ES6. ECMAScript is a standard for
            scripting languages, including JavaScript, JScript, and
            ActionScript. It is also best known as a JavaScript standard
            intended to ensure the interoperability of web pages across
            different web browsers.

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>Class</h3>
            A class is a type of "function", but instead of using the keyword
            "function" to initiate it, we use the keyword "class", and the
            properties are assigned inside a "constructor()" method. We begin
            class name with uppercase. This is a standard naming convention for
            classes. The constructor function is called automatically when the
            object is initialized. We can add our own methods in class. We call
            the method by referring to the object's method name followed by
            parentheses.
            <pre>
class Bike { // class
	constructor(name) { // constructor
		this.brand = name;
	}

	current() { // method
    	return `I have a ${this.brand}.`;
  	}
}

const mybike = new Bike("Pulsar"); // object
// calling a function
mybike.current(); // I have a Pulsar.
		</pre
            >

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>Class Inheritance</h3>
            To create a class inheritance, we use the "extends" keyword. A class
            created with a class inheritance inherits all the methods from
            another class.
            <pre>
class Bike {
	constructor(name) {
		this.brand = name;
	}

	current() {
    	return `I have a ${this.brand}`;
  	}
}

class Model extends Bike {
  	constructor(name, mod) {
    	super(name);
    	this.model = mod;
  	}

	show() {
    	return `${this.current()} it is a ${this.model}`
  	}
}

const mybike = new Model("Pulsar", "Bajaj");
document.write(mybike.show()); // I have a Pulsar it is a Bajaj
		</pre
            >
            The "super()" method refers to the parent class. By calling the
            "super()" method in the constructor method, we call the parent's
            constructor method and get access to the parent's properties and
            methods.

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>Arrow Functions</h3>
            Arrow functions are used to write shourter function syntax.
            <pre>
			before:
			function print() {
				const name = "Ashish Ranjan";
				return `${name}`;
			}
			console.log(print()); // Ashish Ranjan

			now:
			const print = () => {
				const name = "Ashish Ranjan";
				return `${name}`;
			}
			console.log(print()); // Ashish Ranjan
		</pre
            >

            for one statement in function
            <pre>
			const print = (name) => `${name}` ; // single statement function
			console.log(print("India")); // India
			or
			const print1 = name => `${name}` ; // single statement function
			console.log(print1("India")); // India
		</pre
            >

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>this keyword</h3>
            <pre>
class ClassName {
	constructor() {
		this.color = "Red";
  	}

  	printThis1 = () => { // new function
    	console.log(this);
  	}
   	
   	printThis2 = function () { // old function
  		console.log(this);
  	}
}

const className = new ClassName();
document.getElementById("btn1").addEventListener("click", className.printThis1); // [object Object]
document.getElementById("btn2").addEventListener("click", className.printThis2); // [object HTMLButtonElement]
		</pre
            >

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>ES6 Variables</h3>
            Before we had only "var" to define variables. If we did not define
            them, the variables would be assigned to the global object. In
            strict mode, we would get an error if our variables were undefined.
            <br />
            With ES6 we have
            <ul>
                <li><b>var</b>: has a function scope, not a block scope.</li>
                <li><b>let</b>: has a block scope.</li>
                <li>
                    <b>const</b> has a block scope. It does not define a
                    constant value. It defines a constant reference to a value.
                </li>
            </ul>

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>Array Methods</h3>
            The <b>.map()</b> method allows us to run a function on each item in
            the array, returning a new array as the result.
            <pre>
			const myArray = ['apple', 'banana', 'orange'];
			const myList = myArray.map(item => item)
			document.getElementById("demo").innerHTML = myList.toString(); // apple,banana,orange
		</pre
            >

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>Destructuring</h3>
            Destructuring Assignment is a JavaScript expression that allows to
            unpack values from arrays, or properties from objects, into distinct
            variables data can be extracted from arrays, objects, nested objects
            and assigning to variables.
            <pre>
const vehicles = ['monday', 'tuesday', 'wednesday'];
const [day1, day2, day3] = vehicles;
const [day11, , day33] = vehicles;

console.log(day1+" "+day2+" "+day3); // monday tuesday wednesday
console.log(day11+" "+day33); // monday wednesday
		</pre
            >
            <pre>
                function calculate(a, b) {
                    const add = a + b;
                    const subtract = a - b ;
                    const multiply = a * b;
                    const divide = a / b;
                  
                    return [add, subtract, multiply, divide];
                }
                  
                const [add, subtract, multiply, divide] = calculate(2, 9);
                
                console.log("Sum: ", add);
                console.log("Difference ", subtract);
                console.log("Product: ", multiply);
                console.log("Quotient ", divide);
            </pre>
            When destructuring arrays, the order that variables are declared is
            important.
            <br />
            <br />
            <b>Object Destructuring</b>,
            <pre>
const theObject = {
    first: "one",
    second: true,
    third: "three",
    fourth: 4, 
    fifth: false
}

theFunction(theObject); // one true three 4 false
theFunction1(theObject); // one three false

function theFunction({first, second, third, fourth, fifth}) {
    console.log(first, second, third, fourth, fifth);
}

function theFunction1({first, third, fifth}) {
    console.log(first, third, fifth);
}
            </pre>
            The object properties do not have to be declared in a specific
            order.

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>Spread Operator</h3>
            The JavaScript spread operator (...) allows us to quickly copy all
            or part of an existing array or object into another array or object.
            <pre>
example1:
const array1 = [1, 2, 3];
const array2 = [4, 5, 6];
const combined = [...array1, ...array2];
console.log(combined); // (6) [1, 2, 3, 4, 5, 6]

example2:
const numbers = [1, 2, 3, 4, 5, 6];
// const [first, second, ...remaining, last] = numbers; // error Rest element must be last element
const [first, second, ...remaining] = numbers;
console.log(first, second, remaining); // 1 2 (4) [3, 4, 5, 6]

example3:
const user = {
    name: "Ashish Ranjan",
    profession: "Software Developer",
    date: "July 07, 2023",
    year: 2022
  }
  
  const updateUser = {
    name: "New Name",
    profession: "Software Developer",
    date: "July 07, 2023",
    year: 2023
  }
  
  const updatedUser = {...user, ...updateUser}
  console.log(updatedUser); // {name: 'New Name', profession: 'Software Developer', date: 'July 07, 2023', year: 2023}
            </pre>

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>Modules</h3>
            Relies on "import" and "export". Allows us to break up our codes
            into separate files. Two types of exports are "Named" and "Default".
            <pre>
                Named exports (individually):
                export const name = "Ashish Ranjan";
                export const number = 2;

                Named exports (all at once):
                const name = "Ashish Ranjan";
                const number = 2;
                export {name, number};

                Default exports (only one default export possible):
                const user = () => {
                    const name = "Ashish Ranjan";
                    const number = 2;
                };
                export default user;

                import named export from file "user.js";
                import {name, number} from "./user.js";

                import default export from file "user.js";
                import userData from "./user.js";
            </pre>

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>Ternary Operator</h3>
            <pre>authenticated ? renderApp() : renderLogin();</pre>

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>React render html</h3>
            React's goal is in many ways to render HTML in a web page using:
            <ul>
                <li>
                    createRoot(): To define the HTML element where a React
                    component should be displayed.
                </li>
                <li>
                    render(): To define the React component that should be
                    rendered.
                </li>
            </ul>
            /public/index.html -> &lt;div> => this is where our react
            application is rendered
            <pre>
                /src/index.js
                    const root = ReactDOM.createRoot(document.getElementById('root'));
                    root.render(&lt;div>a2rp: an Ashish Ranjan presentation&lt;/div>);

                /public/index.html [result is displayed here]
                    &lt;body>
                        &lt;div id="root">&lt;/div>
                    &lt;/body>

            </pre>
            The element id does not have to be called "root", but this is the
            standard convention.

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>React JSX</h3>
            JSX stands for JavaScript XML and it allows us to write HTML in
            React. We are not required to use JSX, but JSX makes it easier to
            write React applications.
            <pre>
Without JSX:
const myElement = React.createElement('h1', {}, 'without JSX!');
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(myElement);

With JSX:
const myElement = &lt;h1>with JSX!&lt;/h1>;
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(myElement);
            </pre>
            JSX allows us to write HTML directly within the JavaScript code.

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>{ }</h3>
            Expressions can be written inside curly braces and it returns the
            result.
            <pre>
                example1:
                Code:
                3 + 15 = {3 + 15}
                Output:
                3 + 15 = 18
            </pre>
            <pre>
                example2:
                code:
                ...
                const days = (
                    &lt;ul style={{ listStyleType: "none" }}>
                        &lt;li>Sunday&lt;/li>
                        &lt;li>Monday&lt;/li>
                        &lt;li>Tuesday&lt;/li>
                        &lt;li>Wednesday&lt;/li>
                        &lt;li>Thursday&lt;/li>
                        &lt;li>Friday&lt;/li>
                        &lt;li>Saturday&lt;/li>
                    &lt;/ul>
                );
                return (
                    &lt;div className="App">
                        {days}
                    &lt;/div>
                );
                ...

                output:
                    Sunday
                    Monday
                    Tuesday
                    Wednesday
                    Thursday
                    Friday
                    Saturday
            </pre>
            The HTML code must be wrapped in ONE top level element.
            Alternatively, we can use a "fragment" to wrap multiple lines. This
            will prevent unnecessarily adding extra nodes to the DOM.
            <pre>
                fragment:

                &lt;>&lt;/>
            </pre>
            <pre>Attribute class = className</pre>

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>Conditions</h3>
            if statements outside JSX
            <pre>
                code:

                function App() {
                    const checkNumber = (number, limit) => {
                        let text = "";
                        if (number &lt; limit) {
                            text = number + " is less than " + limit;
                        } else {
                            text = number + " is greater than " + limit;
                        }
                        return text;
                    };
                    const element1 = &lt;h1>{checkNumber(24, 11)}&lt;/h1>;
                    const element2 = &lt;h1>{checkNumber(11, 51)}&lt;/h1>;
                
                    return (
                        &lt;div className="App">
                            {element1}
                            {element2}
                        &lt;/div>
                    );
                }
                
                export default App;

                output:

                24 is greater than 11
                11 is less than 51
            </pre>

            using ternary expressions
            <pre>
                code:
                function App() {
                    return (
                        &lt;div className="App">
                            {24 &lt; 11 ? "24 is less than 11" : "24 is greater than 11"}
                            &lt;br />
                            {11 &lt; 51 ? "11 is less than 51" : "11 is greater than 51"}
                            &lt;/div>
                    );
                }
                
                export default App;

                output:
                24 is greater than 11
                11 is less than 51
            </pre>
            To embed a JavaScript expression inside JSX, the JavaScript must be
            wrapped with curly braces, {}.

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>React Components</h3>
            Components are independent and reusable bits of code. They serve the
            same purpose as JavaScript functions, but work in isolation and
            return HTML. React component's name must start with an upper case
            letter.
            <br />
            Two types of components
            <ul>
                <li>Class components</li>
                <li>Function components</li>
            </ul>
            <pre>
                class component:
                class User extends React.Component {
                    render() {
                        return &lt;h2>Hi, I am a Ashish Ranjan!&lt;/h2>;
                    }
                }

                function component:
                const User = () => {
                    return &lt;h2>Hi, I am a Ashish Ranjan!&lt;/h2>;
                }
            </pre>

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>Rendering a component</h3>
            <pre>
                const root = ReactDOM.createRoot(document.getElementById('root'));
                root.render(&lt;User />);
            </pre>

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>Props - Properties</h3>
            Props are like function arguments, and we send them into the
            component as attributes.
            <pre>
                code:
                const User = (props) => {
                    return &lt;h2>I am {props.name}!&lt;/h2>;
                }

                const root = ReactDOM.createRoot(document.getElementById('root'));
                root.render(&lt;User name="Ashish Ranajan"/>);

                output:
                I am Ashish Ranjan!
            </pre>

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>Component inside Component</h3>
            <pre>
                code:
                const FirstName = () => {
                    return &lt;div>My first name is Ashish.&lt;/div>
                };
                
                const FullName = () => {
                    return &lt;div>
                        &lt;FirstName />
                        My last name is Ranjan.
                    &lt;/div>
                };
                
                function App() {
                    return (
                        &lt;div className="App">
                            &lt;FullName />
                        &lt;/div>
                    );
                }
                
                export default App;

                output:
                My first name is Ashish.
                My last name is Ranjan.
            </pre>
            It is recommended to split our components into separate files. To do
            that, we create a new file with a ".js" file extension and put the
            code inside it. The filename must start with an uppercase character.

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>React Class Components</h3>
            Before React 16.8, Class components were the only way to track state
            and lifecycle on a React component. Function components were
            considered "state-less".
            <br />
            With the addition of Hooks, Function components are now almost
            equivalent to Class components. The differences are so minor that we
            will probably never need to use a Class component in React.
            <br />
            Even though Function components are preferred, there are no current
            plans on removing Class components from React.
            <br />
            The component has to include the "extends React.Component"
            statement, this statement creates an inheritance to React.Component,
            and gives your component access to React.Component's functions. The
            component also requires a "render()" method, this method returns
            HTML.
            <pre>
                class User extends React.Component {
                    render() {
                        return &lt;h2>Hi, I am Ashish Ranjan!&lt;/h2>;
                    }
                }
            </pre>
            Now, this is a React component that returns "h2" element and we use
            it like
            <pre>&lt;User /></pre>

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>Class Component Constructor</h3>
            If there is a constructor() function in our component, this function
            will be called when the component gets initiated. The constructor
            function is where we initiate the component's properties. In React,
            component properties should be kept in an object called state.
            <br />
            The constructor function is also where we honor the inheritance of
            the parent component by including the super() statement.
            <pre>
                class User extends React.Component {
                    constructor() {
                        super();
                        this.state = {name: "ashish ranjan"};
                    }
                    render() {
                        return &lt;h2>I am {this.state.color} User!&lt;/h2>;
                    }
                }
            </pre>

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>Class Component Props</h3>
            Another way of handling component properties is by using props.
            Props are like function arguments, and we send them into the
            component as attributes. If our component has a constructor
            function, the props should always be passed to the constructor and
            also to the React.Component via the super() method.
            <pre>
                class User extends React.Component {
                    constructor(props) {
                        super(props);
                    }
                    render() {
                        return &lt;h2>I am {this.props.name}!&lt;/h2>;
                    }
                }
                  
                const root = ReactDOM.createRoot(document.getElementById('root'));
                root.render(&lt;User name="ashish ranjan"/>);
            </pre>

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>Components in Components</h3>
            <pre>
                class Ashish extends React.Component {
                    render() {
                        return &lt;h2>I am Ashish Ranjan!&lt;/h2>;
                    }
                }
                
                class App extends React.Component {
                    render() {
                        return (
                            &lt;div>
                                &lt;h1>Who is a User?&lt;/h1>
                                &lt;Ashish />
                            &lt;/div>
                        );
                    }
                }
            </pre>

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>Class Components in Files</h3>
            In React we re-use code, by inserting some of our components in
            separate files. We create a new file with a ".js" file extension and
            put the code inside it. The file must start by importing React (as
            before), and it has to end with the statement by expoting it.
            <pre>
                import React from 'react';
                class User extends React.Component {
                    render() {
                        return &lt;h2>Hi, I am Ashish Ranjan! &lt;/h2>;
                    }
                }
                export default User;

                to use "User" component
                import React from 'react';
                import ReactDOM from 'react-dom/client';
                import User from './User.js';
                const root = ReactDOM.createRoot(document.getElementById('root'));
                root.render(&lt;User />);
            </pre>

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>React Class Component State</h3>
            React Class components have a built-in state object. The state
            object is where we store property values that belongs to the
            component. When the state object changes, the component re-renders.
            The state object is initialized in the constructor. To change a
            value in the state object, we use the this.setState() method. When a
            value in the state object changes, the component will re-render,
            meaning that the output will change according to the new value(s).
            <pre>
                import "./App.css";
                import React from "react";
                
                class Ashish extends React.Component {
                    constructor(props) {
                        super(props);
                        this.state = {
                            name: props.name,
                            year: props.year,
                            value: 2
                        };
                    }
                
                    handleValueChange = () => {
                        this.setState({ value: 3 });
                    };
                
                    render() {
                        return &lt;>
                            &lt;h2>I am {this.state.name} and the year is {this.state.year} and value = {this.state.value}!&lt;/h2>
                            &lt;div>
                                &lt;button onClick={this.handleValueChange}>click here to change value&lt;/button>
                            &lt;/div>
                        &lt;/>
                    }
                }
                
                class App extends React.Component {
                    render() {
                        return (
                            &lt;div>
                                &lt;Ashish name="ashish ranjan" year={2023} />
                            &lt;/div>
                        );
                    }
                }
                
                export default App;
            </pre>
            "setState()" method is used to change the state object, it will
            ensure that the component knows its been updated and calls the
            "render()" method (and all the other lifecycle methods).

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>Lifecycle of components</h3>
            The three phases are:
            <ul>
                <li>
                    <b>Mounting:</b> Mounting means putting elements into the
                    DOM and has four built-in methods that gets called, in this
                    order, when mounting a component:
                    <ul>
                        <li>
                            constructor() - optional - The constructor() method
                            is called before anything else, when the component
                            is initiated, and it is the natural place to set up
                            the initial state and other initial values.
                        </li>
                        <li>
                            getDerivedStateFromProps() - optional - The
                            getDerivedStateFromProps() method is called right
                            before rendering the element(s) in the DOM.
                        </li>
                        <li>
                            render() - required and called always - The render()
                            method is required, and is the method that actually
                            outputs the HTML to the DOM.
                        </li>
                        <li>
                            componentDidMount() - optional - The
                            componentDidMount() method is called after the
                            component is rendered.
                        </li>
                    </ul>
                </li>
                <li>
                    <b>Updating:</b> A component is updated whenever there is a
                    change in the component's state or props. React has five
                    built-in methods that gets called, in this order, when a
                    component is updated:
                    <ul>
                        <li>
                            getDerivedStateFromProps(): This is the first method
                            that is called when a component gets updated.
                        </li>
                        <li>
                            shouldComponentUpdate(): In the
                            shouldComponentUpdate() method we can return a
                            Boolean value that specifies whether React should
                            continue with the rendering or not.
                        </li>
                        <li>
                            render(): The render() method is of course called
                            when a component gets updated, it has to re-render
                            the HTML to the DOM, with the new changes.
                        </li>
                        <li>
                            getSnapshotBeforeUpdate(): In the
                            getSnapshotBeforeUpdate() method we have access to
                            the props and state before the update, meaning that
                            even after the update, we can check what the values
                            were before the update.
                        </li>
                        <li>
                            componentDidUpdate(): The componentDidUpdate method
                            is called after the component is updated in the DOM.
                        </li>
                    </ul>
                </li>
                <li>
                    <b>Unmounting:</b> The next phase in the lifecycle is when a
                    component is removed from the DOM, or unmounting as React
                    likes to call it. React has only one built-in method that
                    gets called when a component is unmounted:
                    <ul>
                        <li>
                            componentWillUnmount(): The componentWillUnmount
                            method is called when the component is about to be
                            removed from the DOM.
                        </li>
                    </ul>
                </li>
            </ul>

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>React Props - Properties</h3>
            These are arguments [like function arguments] passed into React
            components passed via HTML attributes. Props are also how we pass
            data from one component to another, as parameters. React Props are
            read-only! We will get an error if we try to change their value.
            <pre>
                code:
                const User = (props) => {
                    return (
                        &lt;>
                            &lt;div>First Name: {props.firstName}&lt;/div>
                            &lt;div>Second Name: {props.secondName}&lt;/div>
                            &lt;div>Year: {props.year}&lt;/div>
                            &lt;div>Day: {props.date.day}&lt;/div>
                            &lt;div>Nickname: {props.nickname}&lt;/div>
                        &lt;/>
                    );
                };
                
                const App = () => {
                    const lastName = "Ranjan";
                    const date = {
                        day: "wednesday"
                    };
                    return (
                        &lt;div>
                            &lt;User firstName="Ashish" lastName={lastName} year={2023} date={date} nickname="...ash" />
                        &lt;/div>
                    );
                }
                
                export default App;

                output:
                First Name: Ashish
                Second Name:
                Year: 2023
                Day: wednesday
                Nickname: ...ash                
            </pre>

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>React Events</h3>
            Just like HTML DOM events, React can perform actions based on user
            events. React events are written in camelCase syntax.
            <pre>
                &lt;button onClick={handelButtonClick}>click here&lt;/button>

                e.g.
                onClick
                onMouseOver
                onMouseEnter 
                onMouseLeave
                onMouseMove
            </pre>
            passing arguments
            <pre>
                code:
                const App = () => {
                    const handleClick = (event, value) => {
                        console.log(event.target.type, event.type, value);
                    };
                
                    return (
                        &lt;div>
                            &lt;button onClick={(event) => handleClick(event, new Date())}>click here to see date&lt;/button>
                        &lt;/div>
                    );
                }
                export default App;                

                output:
                submit click Thu Jul 13 2023 09:19:26 GMT+0530 (India Standard Time)
            </pre>
            Event handlers have access to the React event that triggered the
            function. Sending the React event manually.

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>React Conditional Reandering</h3>
            <ul>
                <li>
                    <b>"if" statement rendering</b>
                    <pre>
                        const App = () => {
                            if (-0 > +0) {
                                return &lt;b>-0 is greater than +0&lt;/b>
                            } else {
                                return &lt;b>+0 is greater than -0&lt;/b>
                            }
                        }
                        export default App;

                        output:
                        +0 is greater than -0
                    </pre>
                </li>
                <li>
                    <b>logical && operator</b>
                    <pre>
                        code:
                        const App = () => {
                            return (
                                &lt;>
                                    {1 > 2 && &lt;b>1 is greater than 2&lt;/b>}
                                    {1 &lt; 2 && &lt;b>1 is less than 2&lt;/b>}
                                &lt;/>
                            );
                        }                        
                        export default App;
                        
                        output:
                        1 is less than 2
                    </pre>
                </li>
                <li>
                    <b>ternary operator</b>
                    <pre>
                        const App = () => {
                            return (
                                &lt;>
                                    {1 > 2 ? &lt;b>1 is greater than 2&lt;/b> : &lt;b>1 is not greater than 2&lt;/b>}
                                    &lt;br />
                                    {1 &lt; 2 ? &lt;b>1 is less than 2&lt;/b> : &lt;b>1 is not less than 2&lt;/b>}
                                &lt;/>
                            );
                        }
                        
                        export default App;

                        output:
                        1 is not greater than 2
                        1 is less than 2
                    </pre>
                </li>
            </ul>

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>React Lists</h3>
            Lists are rendered with some type of loop and map() array method is
            generally prefered.
            <br />
            Keys allow React to keep track of elements. So, if an item is
            updated or removed, only that item will be re-rendered instead of
            the entire list. Keys need to be unique to each sibling. But they
            can be duplicated globally. Generally, the key should be a unique ID
            assigned to each item. As a last resort, we can use the array index
            as a key.
            <pre>
                const App = () => {
                    const list1 = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
                    const list2 = {
                        1: "one",
                        2: "two",
                        5: "four",
                        7: "seven"
                    };
                
                    return (
                        &lt;>
                            list1
                            {
                                Array.isArray(list1)
                                    ? list1.map((item, index) => (
                                        &lt;div key={index}>{index}. {item}&lt;/div>
                                    )) : null
                            }
                
                            list2
                            {Object.keys(list2).map(key => (
                                &lt;div key={key}>
                                    {key}. {list2[key]}
                                &lt;/div>
                            ))}
                        &lt;/>
                    );
                }
                
                export default App;
                
                output:
                list1
                0. Sunday
                1. Monday
                2. Tuesday
                3. Wednesday
                4. Thursday
                5. Friday
                6. Saturday
                list2
                1. one
                2. two
                5. four
                7. seven
            </pre>

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>React Forms</h3>
            Handling forms is about how we handle the data when it changes value
            or gets submitted.
            <table>
                <thead>
                    <tr>
                        <th>HTML</th>
                        <th>React</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>
                            In HTML, form data is usually handled by the DOM.
                        </td>
                        <td>
                            In React, form data is usually handled by the
                            components.
                        </td>
                    </tr>
                </tbody>
            </table>
            When the data is handled by the components, all the data is stored
            in the component state. We can control changes by adding event
            handlers in the "onChange" attribute. We can use the "useState" Hook
            to keep track of each inputs value and provide a "single source of
            truth" for the entire application.
            <pre>
import { useEffect, useState } from "react";

const App = () => {
    const [inputs, setInputs] = useState({});

    const handleChange = event => {
        const name = event.target.name;
        const value = event.target.value;
        setInputs(values => ({ ...values, [name]: value }));
    };

    useEffect(() => {
        console.log(inputs);
    }, [inputs]);

    const handleSubmit = event => {
        event.preventDefault();
        console.log(inputs);
    };

    return (
        &lt;div>
            &lt;form onSubmit={handleSubmit} style={{ margin: "15px" }}>
                &lt;label htmlFor="firstName">
                    First Name: &lt;br />
                    &lt;input type="text" name="firstName" value={inputs.firstName || ""} onChange={handleChange} />
                &lt;/label>
                &lt;br />
                &lt;br />

                &lt;label htmlFor="lastName">
                    Last Name: &lt;br />
                    &lt;input type="text" name="lastName" value={inputs.lastName || ""} onChange={handleChange} />
                &lt;/label>
                &lt;br />
                &lt;br />

                &lt;label htmlFor="gender">
                    Gender: &lt;br />
                    &lt;select name="gender" id="gender" value={inputs.gender || "male"} onChange={handleChange}>
                        &lt;option value="Male">Male&lt;/option>
                        &lt;option value="Female">Female&lt;/option>
                    &lt;/select>
                &lt;/label>
                &lt;br />
                &lt;br />

                &lt;label htmlFor="message">
                    Message: &lt;br />
                    &lt;textarea name="message" id="message" cols="30" rows="10" value={inputs.message || ""} onChange={handleChange} />
                &lt;/label>
                &lt;br />
                &lt;br />

                &lt;input type="submit" value="Submit" />
            &lt;/form>
        &lt;/div>
    );
}

export default App;

            </pre>
            I used the same event handler function for both input fields, we
            could write one event handler for each, but this gives us much
            cleaner code and is the preferred way in React.

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>React Router</h3>
            "create-react-app" doesn't include page routing. React Router is the
            most popular solution.
            <pre>
                install react router
                npm install --save-prod react-router-dom
            </pre>
            folder structure of application
            <pre>
                /src/pages/
                    Layout.js
                    Home.js
                    About.js
                    Blogs.js
                    Downloads.js
                    a2rp.js
                    NoPage.js
            </pre>
            <pre>
File: App.js

import { BrowserRouter, Route, Routes } from "react-router-dom";
import Home from "./pages/Home";
import Blogs from "./pages/Blogs";
import Downloads from "./pages/Downloads";
import NoPage from "./pages/NoPage";
import Layout from "./pages/Layout";

const App = () => {
    return (
        // contect is wrapped in BrowserRouter
        &lt;BrowserRouter>
            {/* then routes are defined and an application can havre multiple Routes */}
            &lt;Routes>
                &lt;Route path="/" element={&lt;Layout />}>
                    {/* The Home component route does not have a path but has an index attribute. That specifies this route as the default route for the parent route, which is "/". */}
                    &lt;Route index element={&lt;Home />} />
                    &lt;Route path="blogs" element={&lt;Blogs />} />
                    {/* The nested &lt;Route>'s inherit and add to the parent route. So the "downloads" path is combined with the parent and becomes "/downloads". */}
                    &lt;Route path="downloads" element={&lt;Downloads />} />
                    {/* Setting the path to * will act as a catch-all for any undefined URLs. This is great for a 404 error page. */}
                    &lt;Route path="*" element={&lt;NoPage />} />
                &lt;/Route>
            &lt;/Routes>
        &lt;/BrowserRouter>
    );
}

export default App;

            </pre>
            The Layout component has &lt;Outlet> and &lt;Link> elements. The
            &lt;Outlet> renders the current route selected. &lt;NavLink> is used
            to set the URL. Anytime we link to an internal path, we will use
            &lt;NavLink> instead of &lt;a href="">. The "layout route" is a
            shared component that inserts common content on all pages, such as a
            navigation menu.

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>React Memo</h3>
            If this component iss complex, it could cause performance issues on
            re-rendering it. So, we use memo to render component only if it has
            changed.
            <pre>
File: App.js
import WithMemoComponents from "./components/WithMemoComponents";
import WithoutMemoComponents from "./components/WithoutMemoComponents";
import { useState } from "react";

const App = () => {
    const [count, setCount] = useState(0);

    return (
        &lt;div style={{ textAlign: "center" }}>
            &lt;WithoutMemoComponents />
            &lt;WithMemoComponents />

            &lt;div>
                &lt;input type="submit" value="Increment Counter" onClick={() => setCount(prev => prev + 1)} />
                &lt;div>{count}&lt;/div>
                &lt;input type="submit" value="Decrement Counter" onClick={() => setCount(prev => prev - 1)} />
            &lt;/div>
        &lt;/div>
    );
}
export default App;

File: WithoutMemoComponents.js
import React, { memo } from 'react'

const WithoutMemoComponents = () => {
    return (
        &lt;h1>
            with memo: {new Date().toISOString()}
        &lt;/h1>
    )
}
export default WithoutMemoComponents;

File: WithMemoComponents.js
import React, { memo } from 'react'

const WithMemoComponents = () => {
    return (
        &lt;h1>
            with memo: {new Date().toISOString()}
        &lt;/h1>
    )
}
export default memo(WithMemoComponents);
            </pre>

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>React CSS Inline Styling</h3>
            <pre>
                &lt;div styles={{color: "red"}}>ashish ranjan&lt;/div>
            </pre>

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>React CSS JavaScript Object</h3>
            <pre>
                const style1 = {
                    color: "white",
                    padding: "20px",
                };
                ...
                &lt;div style={style1}>ashish ranjan&lt;/div>
            </pre>

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>React CSS Stylesheet</h3>
            <pre>
                File: styles.css
                body {
                    color: red;
                    background-color: green;
                }

                import css file in the file to use css
                import "./styles.css";
                ...
                &lt;div>ashish ranjan&lt;/div>
            </pre>

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>React CSS Modules</h3>
            The CSS inside a module is available only for the component that
            imported it, and we do not have to worry about name conflicts.
            <pre>
                File: styles.module.css
                .name {
                    color: red;
                    background-color: green;
                }

                import css file in the file to use css
                import styles from "./styles.module.css";
                ...
                &lt;div className={styles.name}>ashish ranjan&lt;/div>
            </pre>

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>React SASS Styling</h3>
            Sass is a CSS pre-processor. Sass files are executed on the server
            and sends CSS to the browser.
            <pre>
                install sass
                npm install sass --save-prod

                example
                file: styles.scss
                $fontSizeValue: 20px;
                div {
                    font-size: $fontSizeValue;
                }

                file: App.js
                import "./styles.scss";
                ...
                &lt;div>ashish ranjan&lt;/div>
            </pre>

            <div class="a2rpRight">a2rp: an Ashish Ranjan presentation</div>

            <h3>React Hooks</h3>
            Hooks are a new addition in React 16.8. They let us use state and
            other React features without writing a class. We use "import" Hooks
            "from react". React hooks rules
            <ul>
                <li>
                    We can only call hooks at the top level of our component or
                    our own hooks.
                </li>
                <li>We cannot call hooks inside loops or conditions.</li>
                <li>
                    We can only call hooks from React functions, and not regular
                    JavaScript functions.
                </li>
            </ul>
            Hooks will not work in React class components.
            <br />
            <b>Custom Hooks:</b> If we have stateful logic that needs to be
            reused in several components, we can build our own custom Hooks.
            <br /><br />
            React Hooks are simple JavaScript functions that we can use to
            isolate the reusable part from a functional component. Hooks can be
            stateful and can manage side-effects. React provides a bunch of
            standard in-built hooks:
            <ul>
                <li>
                    <b>useState:</b> To manage states. Returns a stateful value
                    and an updater function to update it.
                </li>
                <li>
                    <b>useEffect:</b> To manage side-effects like API calls,
                    subscriptions, timers, mutations, and more.
                </li>
                <li>
                    <b>useContext:</b> To return the current value for a
                    context.
                </li>
                <li>
                    <b>useReducer:</b> A useState alternative to help with
                    complex state management.
                </li>
                <li>
                    <b>useCallback:</b> It returns a memorized version of a
                    callback to help a child component not re-render
                    unnecessarily.
                </li>
                <li>
                    <b>useMemo:</b> It returns a memoized value that helps in
                    performance optimizations.
                </li>
                <li>
                    <b>useRef:</b> It returns a ref object with a .current
                    property. The ref object is mutable. It is mainly used to
                    access a child component imperatively.
                </li>
                <li>
                    <b>useLayoutEffect:</b> It fires at the end of all DOM
                    mutations. It's best to use useEffect as much as possible
                    over this one as the useLayoutEffect fires synchronously.
                </li>
                <li>
                    <b>useDebugValue:</b> Helps to display a label in React
                    DevTools for custom hooks.
                </li>
            </ul>
        </div>
    </body>
</html>
